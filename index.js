import MagicString from "magic-string";

export default function importSideEffectPlugin (options) {
  if (!options || !options.importFnName) {
    throw new Error("importSideEffectPlugin: Please provide options object with `importFnName` key")
  }
  if (!options.sourceMapOptions) {
    // See https://github.com/rich-harris/magic-string#sgeneratemap-options-
    options.sourceMapOptions = {};
  }
  if (options.sourceMapOptions.hires === undefined) {
    options.sourceMapOptions.hires = true; // high resolution source maps by default
  }
  return {
    name: '@raquo/vite-plugin-import-side-effect',
    transform (code, id) {
      const {moduleId, querySuffix} = splitModuleId(id);

      // #TODO We only want to process JS files generated by scala.js,
      //  processing any other files is a waste of CPU cycles.
      if (moduleId.endsWith(".js") && !moduleId.includes("node_modules")) {
        const str = new MagicString(code);
        const pattern = new RegExp(`${options.importFnName}\\("([^"]+)"\\)`, 'g');
        const sideEffectImports = []

        let match = null;
        while ((match = pattern.exec(code)) !== null) {
          sideEffectImports.push(match[1])
          str.appendLeft(match.index, "// ") // comment out the invocation of our non-existent function.
        }

        if (sideEffectImports.length > 0) {

          // Kind of fragile, because I don't really know what the modules can possibly look like in all cases.
          let insertAtIndex = 0
          if (code.startsWith("'use strict';\n")) {
            insertAtIndex = code.indexOf("\n") // second line
          }

          const importStatements = [
            "// -- Begin imports via import-side-effect --"
          ]
          sideEffectImports.forEach(importModuleName => {
            importStatements.push(`import "${importModuleName}";`)
          })
          importStatements.push(
            "// -- End imports via import-side-effect --"
          )

          // Imports must be at the top level in the module.
          // Note: We're inserting these side effecting imports before any other imports inserted by Scala.js.
          str.appendLeft(insertAtIndex, importStatements.join("\n"))

          return {
            code: str.toString(),
            map: str.generateMap(options.sourceMapOptions)
          };
        } else {
          return null;
        }
      }
    }
  };
}

/** Helper to split e.g. "foo.css?used" into "foo" and "?used" */
export function splitModuleId (id) {
  const indexOfQuery = id.lastIndexOf("?");
  let moduleId = id;
  let querySuffix = ""
  if (indexOfQuery !== -1) {
    moduleId = id.substring(0, indexOfQuery)
    querySuffix = id.substring(indexOfQuery)
  }
  return {
    moduleId, // anything before the last "?", or the whole module id if there is no query
    querySuffix // everything after and including "?", or an empty string if there is no query
  }
}
